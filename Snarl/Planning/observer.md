# MEMORANDUM

#### DATE: March 11, 2021
#### TO: Growl, Inc.
#### FROM: William Victoria and Luke Novak, Software Developers, Ormegland Inc.
#### SUBJECT: Snarl Observer

---

This memo presents our plan for the Observer component that will be used in our implementation of Snarl. Our Observer will run on a separate thread from the Game Manager. The Game Manager and the Observer will communicate using a channel. The Observer has the following functions:

1. Receive the game state from the Game Manager
2. Render the current game state
3. Not make changes to the game state

### Planned Code

```Go
type GameObserver struct {
    GameStateChannel chan GameState
    callback         func(GameState)
}

// Used to create a new Game Observer with a buffer size of 1 state
func NewGameObserver(callback func(GameState)) {
    return GameObserver{GameStateChannel: make(chan GameState, 1)} // buffer size of 1
}

// Begins listening for GameStates on the channel. When received, executes the given callback
func (observer GameObserver) Begin() {
    for state := range observer.GameStateChannel {
        callback(state)
    }
}
```

Our `GameObserver` struct is simply a wrapper around a *channel* of `GameState`, meaning that
as part of our loop in the `GameManager`, we can update the `GameObserver` with a single line
of code for each observer:

> `observer.GameStateChannel <- state`

At the start of the game, if there is an observer it will be generated by the function that
calls the Game Manager to start the game. So, our game manager will also now take a slice of
`GameObserver` as a parameter. From there, we initialize any observers with a `for` loop at the 
beginning of the manager's `GameLoop` function before we enter the main game loop.

```Go
for _, observer := range observers {
    go observer.Begin()
}
```

Our Observer will use the same rendering code as our player client to render the current game state. Because
the Observer has access to the entire game level, however, they will be able to render the entire level unlike 
the Player Clients. For the additional debug info, the Observer window will also render a number of data points 
about the Game overall below the Level. If time permits, we would also like to implement a system where clicking
on a tile or `Actor` displays some information about it specifically, however this feature is time sensitive.

Note that the call to render the observer's state will be done as a local observer's `callback`.

For future extensions of the Observer that work over the network, the callback will just need to be changed to
a function that sends the necessary data over a TCP connection. Since the callback determines the action that is
performed on the game state, we can use the same structure for all sorts of actions, using a render function or sending
info over the network.
