# MEMORANDUM

#### DATE: March 11, 2021
#### TO: Growl, Inc.
#### FROM: William Victoria and Luke Novak, Software Developers, Ormegland Inc.
#### SUBJECT: Snarl Observer

---

This memo presents our plan for the Observer component that will be used in our implementation of Snarl. Our Observer will run on a separate thread from the Game Manager. The Game Manager and the Observer will communicate using a channel. The Observer has the following functions:

1. Receive the game state from the Game Manager
2. Render the current game state
3. Not make changes to the game state

### Planed Code

```Go
type GameObserver struct {
    GameStateChannel chan GameState
    callback         func(GameState)
}

// Used to create a new Game Observer with a buffer size of 1 state
func NewGameObserver(callback func(GameState)) {
    return GameObserver{GameStateChannel: make(chan GameState, 1)} // buffer size of 1
}

// Begins listening for GameStates on the channel. When received, executes the given callback
func (observer GameObserver) Begin() {
    for state := range observer.GameStateChannel {
        callback(state)
    }
}
```

Our `GameObserver` struct is simply a wrapper around a *channel* of `GameState`, meaning that
as part of our loop in the `GameManager`, we can update the `GameObserver` with a single line
of code for each observer:

> `observer.GameStateChannel <- state`

At the start of the game, if there is an observer it will be generated by the function that
calls the Game Manager to start the game. So, our game manager will also now take a slice of
`GameObserver` as a parameter. From there, we initialize any observers with a `for` loop at the 
beginning of the manager's `GameLoop` function before we enter the main game loop.

```Go
for _, observer := range observers {
    go observer.Begin()
}
```

Our Observer will use the same code as our player client to render the current game state.
